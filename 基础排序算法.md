# 排序算法

- [排序算法](#排序算法)
  - [比较类排序](#比较类排序)
    - [交换排序](#交换排序)
      - [快排](#快排)
      - [冒泡](#冒泡)
    - [插入排序](#插入排序)
      - [简单插入排序](#简单插入排序)
      - [希尔](#希尔)
    - [选择排序](#选择排序)
      - [简单选择排序](#简单选择排序)
      - [堆排序](#堆排序)
    - [归并排序](#归并排序)
      - [二路归并排序](#二路归并排序)
      - [多路归并排序](#多路归并排序)
  - [非比较排序](#非比较排序)
    - [计数排序](#计数排序)
    - [桶排序](#桶排序)
    - [基数排序](#基数排序)

## 比较类排序

### 交换排序

#### 快排

- 思想：选择key，创建左右游标，在右游标比左游标大时：右游标左移，直到找到小于key的值，交换；左游标右移，直到找到大于key的值，交换。递归处理左右列表直到需处理部分为原子式。
- 时间复杂度：O（nlogn），空间复杂度：O（1）
- 代码

```python
def quick_sort(lst, low, high):
    # low>=high , 说明要处理部分的已经是原子式了
    if low >= high:
        return
    # 定义两个游标，分别指向0和末尾位置
    left, right = low, high
    # 把left位置的数据作为key缓存下来
    key = lst[left]
    while left < right:
        # 让右边游标往左移动，直到找到小于key的值
        while left < right and lst[right] >= key:
            right -= 1
        lst[left] = lst[right]
        # 让左边游标往右移动，直到找到大于key的值
        while left < right and lst[left] < key:
            left += 1
        lst[right] = lst[left]
    # while结束后，left==right，把key放到中间位置
    lst[left] = key
    # 递归处理左边的数据
    quick_sort(lst, low, left-1)
    # 递归处理右边的数据
    quick_sort(lst, left+1, high)
 
l = [1,5,2,3,5,5,6,4,8,4,1,1,2,2]
quick_sort(l, 0, len(l)-1)
print(l)
```

#### 冒泡

### 插入排序

#### 简单插入排序

#### 希尔

### 选择排序

#### 简单选择排序

#### 堆排序

### 归并排序

#### 二路归并排序

```py
def merge(lst_left: list, lst_right: list) -> list:
    left, right = 0, 0
    left_l, right_l = len(lst_left), len(lst_right)

    new_list = []
    while left < left_l and right < right_l:
        if lst_left[left] <= lst_right[right]:
            new_list.append(lst_left[left])
            left += 1
        else:
            new_list.append(lst_right[right])
            right += 1
    # 剩余列表直接extend至列表尾
    new_list += lst_left[left:]
    new_list += lst_right[right:]
    return new_list


def merge_sort(lst: list) -> list:
    if len(lst) <= 1:
        return lst

    mid = len(lst) // 2
    lst_left = merge_sort(lst[:mid])
    lst_right = merge_sort(lst[mid:])
    return merge(lst_left, lst_right)
```

#### 多路归并排序

## 非比较排序

### 计数排序

### 桶排序

### 基数排序
