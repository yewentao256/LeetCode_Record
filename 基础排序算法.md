# 排序算法

## 比较类排序

### 交换排序

#### 快排

- 思想：选择key，创建左右游标，在右游标比左游标大时：右游标左移，直到找到小于key的值，交换；左游标右移，直到找到大于key的值，交换。递归处理左右列表直到需处理部分为原子式。
- 时间复杂度：O（nlogn），空间复杂度：O（1）
- 代码

```python
def quick_sort(lst, low, high):
    # low>=high , 说明要处理部分的已经是原子式了
    if low >= high:
        return
    # 定义两个游标，分别指向0和末尾位置
    left, right = low, high
    # 把left位置的数据作为key缓存下来
    key = lst[left]
    while left < right:
        # 让右边游标往左移动，直到找到小于key的值
        while left < right and lst[right] >= key:
            right -= 1
        lst[left] = lst[right]
        # 让左边游标往右移动，直到找到大于key的值
        while left < right and lst[left] < key:
            left += 1
        lst[right] = lst[left]
    # while结束后，left==right，把key放到中间位置
    lst[left] = key
    # 递归处理左边的数据
    quick_sort(lst, low, left-1)
    # 递归处理右边的数据
    quick_sort(lst, left+1, high)
 
l = [1,5,2,3,5,5,6,4,8,4,1,1,2,2]
quick_sort(l, 0, len(l)-1)
print(l)
```

#### 冒泡

### 插入排序

#### 简单插入排序

#### 希尔

### 堆排序

- 思路
    大根堆——根节点比左右子结点大，对于左右子树递归如此。（升序用大根堆，降序用小根堆）
    首先构建大根堆，从第一个非叶子结点开始倒序遍历，对于每一个非叶子结点都进行调整，得到大根堆。
    随后进行排序，排序思想：每一次将根（最大元素）放至列表末尾，同时调整大根堆。

- 时间复杂度：O（nlogn），空间复杂度：O（1）

```py
def build_heap(nums: list, index: int, high: int):
    ''' 构建大顶堆 '''
    left, right = 2 * index + 1, 2 * index + 2      # 左右子节点的下标

    # 比较得到最大的index
    large_index = index
    if left <= high and nums[index] < nums[left]:
        large_index = left
    if right <= high and nums[large_index] < nums[right]:
        large_index = right

    # 如果较大index不是父节点的index，说明交换后需要重新调整大顶堆
    if large_index != index:
        nums[index], nums[large_index] = nums[large_index], nums[index]
        build_heap(nums, large_index, high)


def heap_sort(nums: list):
    ''' 堆排序 '''
    len_nums = len(nums)
    # 构造大顶堆，l // 2 -1 为最后一个非叶子节点，倒序遍历每一个非叶子结点
    for i in range(len_nums // 2 - 1, -1, -1):
        build_heap(nums, i, len_nums - 1)
    # 逐个把根节点跟末尾节点交换，然后重新调整大顶堆
    for j in range(len_nums - 1, -1, -1):
        nums[0], nums[j] = nums[j], nums[0]
        build_heap(nums, 0, j - 1)

    return nums


nums = [1, 3, 2, 1, 5, 3, 2, 6, 1]
print(heap_sort(nums))
```

### 归并排序

```py
def merge(lst_left: list, lst_right: list) -> list:
    left, right = 0, 0
    left_l, right_l = len(lst_left), len(lst_right)

    new_list = []
    while left < left_l and right < right_l:
        if lst_left[left] <= lst_right[right]:
            new_list.append(lst_left[left])
            left += 1
        else:
            new_list.append(lst_right[right])
            right += 1
    # 剩余列表直接extend至列表尾
    new_list += lst_left[left:]
    new_list += lst_right[right:]
    return new_list


def merge_sort(lst: list) -> list:
    if len(lst) <= 1:
        return lst

    mid = len(lst) // 2
    lst_left = merge_sort(lst[:mid])
    lst_right = merge_sort(lst[mid:])
    return merge(lst_left, lst_right)
```

## 非比较排序

### 计数排序

### 桶排序

### 基数排序
